using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading; // For pauses

// ####################################################
// ########         CORE GAME CLASSES          ########
// ####################################################

#region Core Game Classes

/// <summary>
/// Enum to represent the ability affected by a card modifier
/// </summary>
public enum AffectedAbility
{
	None, // Default or for cards with non-modifier effects
	Investigation,
	Detection,
	Combat,
	Movement // Represents modification to movement roll result
}

/// <summary>
/// Base class for all cards in the game.
/// </summary>
public abstract class Card
{
	public string Name { get; protected set; }
	public string Type { get; protected set; } // Clue, Hassle, Help, Suspect, Replicant

	protected Card(string name, string type)
	{
		Name = name;
		Type = type;
	}

	// Example placeholder for playing - specific cards should override
	public virtual void Play(Player source, Player target, Game game)
	{
		Console.WriteLine($"{source?.Name ?? "Someone"} plays {Name}. (Base effect not implemented)");
	}

	public override string ToString()
	{
		// Provides a clean representation for console output
		string details = $" ({Type})";
		if (this is HelpCard hc && hc.AbilityAffected != AffectedAbility.None)
			details = $" ({Type}: {hc.ModifierAmount:+0;-#}{hc.AbilityAffected} @ {hc.TargetLocation ?? "Anywhere"})";
		else if (this is ClueCard cl && cl.AbilityAffected != AffectedAbility.None)
			details = $" ({Type}: {cl.ModifierAmount:+0;-#}{cl.AbilityAffected} @ {cl.TargetLocation ?? "Anywhere"})";
		else if (this is HassleCard hs && hs.AbilityAffected != AffectedAbility.None)
			details = $" ({Type}: {hs.ModifierAmount:+0;-#}{hs.AbilityAffected} @ {hs.TargetLocation ?? "Anywhere"})";
		else if (this is SuspectCard sc)
			details = $" ({Type}: Evasion {sc.Evasion})";
		else if (this is ReplicantCard rc)
			details = $" ({Type}: Combat {rc.Combat})";

		return $"{Name}{details}";
	}
}

// --- Specific Card Types ---

public class SuspectCard : Card
{
	public int Evasion { get; private set; }
	public SuspectCard(string name, int evasion) : base(name, "Suspect") {
		Evasion = evasion;
	}
}

public class ReplicantCard : Card
{
	public int Combat { get; private set; }
	public ReplicantCard(string name, int combat) : base(name, "Replicant") {
		Combat = combat;
	}
}

public class HelpCard : Card
{
	public AffectedAbility AbilityAffected { get; private set; }
	public int ModifierAmount { get; private set; } // Positive for Help
	public string TargetLocation { get; private set; } // null or empty if applies anywhere

	// Constructor for Help cards that modify an ability
	public HelpCard(string name, AffectedAbility ability, int amount, string location = null)
		: base(name, "Help")
	{
		AbilityAffected = ability;
		ModifierAmount = Math.Max(0, amount);
		TargetLocation = location;
	}
	// Constructor for Help cards with other non-modifier effects
	public HelpCard(string name) : base(name, "Help")
	{
		AbilityAffected = AffectedAbility.None;
		ModifierAmount = 0;
		TargetLocation = null;
	}
}

public class ClueCard : Card
{
	public AffectedAbility AbilityAffected { get; private set; } // Likely Investigation
	public int ModifierAmount { get; private set; } // Positive for Clue
	public string TargetLocation { get; private set; } // Usually specific

	// Constructor for Clue cards
	public ClueCard(string name, int amount, string location = null) : base(name, "Clue")
	{
		AbilityAffected = AffectedAbility.Investigation; // Per rules [cite: 203]
		ModifierAmount = Math.Max(1, amount);
		TargetLocation = location ?? null;//throw new ArgumentNullException(nameof(location), "Clue card must specify a target location.");
	}
	// Constructor for Clue cards with non-standard effects?
	public ClueCard(string name) : base(name, "Clue")
	{
		AbilityAffected = AffectedAbility.None;
		ModifierAmount = 0;
		TargetLocation = null;
	}
}

public class HassleCard : Card
{
	public AffectedAbility AbilityAffected { get; private set; }
	public int ModifierAmount { get; private set; } // Negative for Hassle
	public string TargetLocation { get; private set; } // null or empty if applies anywhere

	// Constructor for Hassle cards that modify an ability
	public HassleCard(string name, AffectedAbility ability, int amount, string location = null)
		: base(name, "Hassle")
	{
		AbilityAffected = ability;
		ModifierAmount = Math.Min(0, amount);
		TargetLocation = location;
	}
	// Constructor for Hassle cards with other non-modifier effects
	public HassleCard(string name) : base(name, "Hassle")
	{
		AbilityAffected = AffectedAbility.None;
		ModifierAmount = 0;
		TargetLocation = null;
	}
}


/// <summary>
/// Represents a deck of cards (Draw, Discard, Replicant).
/// </summary>
public class Deck
{
	public List<Card> cards;
	private Random rng = new Random();

	public int Count => cards.Count;
	public bool IsEmpty => cards.Count == 0;

	public Deck(bool isEmpty = false)
	{
		cards = new List<Card>();
		if (!isEmpty) InitializeDeck();
	}

	// Populate with sample cards - REPLACE with full card list from rules [cite: 188]
	private void InitializeDeck()
	{
		// Based on rules: 9 Clues, 12 Hassles, 19 Helps, 15 Suspects = 55 cards
		// Clues (Example names from rules/film)
		cards.Add(new ClueCard("Not Fish... Snake Scale!", 1, "Snake Pit"));
		cards.Add(new ClueCard("That's the Hotel", 1, "Yukon Hotel"));
		cards.Add(new ClueCard("Precious Photos", 1)); // Special clue, applies anywhere? Treat as +1 Inv? [cite: 94]
		cards.Add(new ClueCard("Esper Analysis", 1, "Police HQ")); // Assumption
		cards.Add(new ClueCard("Genetic Identity", 1, "Tyrell Corp")); // Assumption
		// Add 4 more unique Clues...
		//cards.Add(new ClueCard("Clue 6", 1, "Animoid Row"));
		//cards.Add(new ClueCard("Clue 7", 1, "White Dragon"));
		//cards.Add(new ClueCard("Clue 8", 1, "Bradbury Building"));
		//cards.Add(new ClueCard("Clue 9", 1, "Chinatown"));


		// Hassles (Examples)
		cards.Add(new HassleCard("Buzz Off", AffectedAbility.Investigation, -1, "Snake Pit"));
		cards.Add(new HassleCard("Time to Die!", AffectedAbility.Combat, -1));
		cards.Add(new HassleCard("And If the Machine Doesn't Work?", AffectedAbility.Detection, -1));
		cards.Add(new HassleCard("You Not Come Here!", AffectedAbility.Investigation, -1, "Eyeworks"));
		cards.Add(new HassleCard("Spinner Crash", AffectedAbility.Movement, -2)); // Example movement hassle
		// Add 7 more unique Hassles...
		//for(int i=0; i<7; i++) cards.Add(new HassleCard($"Hassle {i+5}", AffectedAbility.Investigation, -1));


		// Helps (Examples)
		cards.Add(new HelpCard("That's the Spirit!", AffectedAbility.Combat, 1));
		cards.Add(new HelpCard("Desperate Leap")); // Special effect card, no modifier
		cards.Add(new HelpCard("I Owe You One")); // Special effect card
		cards.Add(new HelpCard("Street Smarts", AffectedAbility.Investigation, 1)); // Example
		cards.Add(new HelpCard("Keen Eye", AffectedAbility.Detection, 1)); // Example
		cards.Add(new HelpCard("Quick Reflexes", AffectedAbility.Combat, 1)); // Example
		cards.Add(new HelpCard("Shortcut", AffectedAbility.Movement, 1)); // Example movement help
		// Add 12 more unique Helps...
		//for(int i=0; i<12; i++) cards.Add(new HelpCard($"Help {i+5}", AffectedAbility.Detection, 1));


		// Suspects (Examples)
		cards.Add(new SuspectCard("Abdul Ben Hassan", 5)); // Example names
		cards.Add(new SuspectCard("Taffey Lewis", 6));
		cards.Add(new SuspectCard("Hannibal Chew", 7));
		cards.Add(new SuspectCard("Cambodian Lady", 5));
		cards.Add(new SuspectCard("Bartender", 6));
		// Add 10 more unique Suspects...
		//for(int i=0; i<10; i++) cards.Add(new SuspectCard($"Suspect {i+6}", (i % 3) + 5)); // Evasion 5-7
		//----
		//
		cards.Add(new HelpCard("I Owe You One..."));
		cards.Add(new SuspectCard("Suspicious Character", 7));
		cards.Add(new SuspectCard("Suspicious Character", 6));
		cards.Add(new HassleCard("You Not Come Here!", AffectedAbility.Investigation, -1, "Eyeworks"));
		cards.Add(new ClueCard("Not Fish... Snake Scale!", 1, "Snake Pit"));
		cards.Add(new ClueCard("Look, My Friend...", 1, "Chinatown"));
		cards.Add(new HelpCard("Street Bandits", AffectedAbility.Investigation, 1)); // Example
		cards.Add(new ClueCard("The Prodigal Son Brings Death", 2, "Tyrell Corp"));
		cards.Add(new ClueCard("Look, My Friend...", 1, "Chinatown"));
		cards.Add(new HassleCard("Dense Crowd", AffectedAbility.Investigation, -1, "Chinatown"));
		cards.Add(new SuspectCard("Suspicious Character", 7));
		cards.Add(new HelpCard("Spinner Travel", AffectedAbility.Movement, 10)); // Example movement help
		cards.Add(new SuspectCard("Suspicious Character", 5));
		cards.Add(new SuspectCard("Suspicious Character", 7));
		cards.Add(new ClueCard("Hang Up", 2, "Bradbury Building"));
		cards.Add(new HelpCard("One More Question...", AffectedAbility.Detection, 1)); // Example
		cards.Add(new HelpCard("Queen to Bishop Six"));
		cards.Add(new HassleCard("Must Be Expensive", AffectedAbility.Investigation, -1, "Animoid Row"));
		cards.Add(new SuspectCard("Suspicious Character", 7));
		cards.Add(new HelpCard("Queen to Bishop Six"));
		cards.Add(new ClueCard("That's the Hotel", 2, "Yukon Hotel"));
		cards.Add(new ClueCard("Gimme Four", 1, "White Dragon"));
		cards.Add(new SuspectCard("Suspicious Character", 5));
		cards.Add(new HassleCard("Indulge Me", AffectedAbility.Investigation, -1, "Tyrell Corp"));
		cards.Add(new SuspectCard("Suspicious Character", 6));
		cards.Add(new HelpCard("Spinner Travel", AffectedAbility.Movement, 10)); // Example movement help
		cards.Add(new HelpCard("Our Best and Only Friend"));
		cards.Add(new HassleCard("Nobody Home", AffectedAbility.Investigation, -1, "Yukon Hotel"));
		cards.Add(new SuspectCard("Suspicious Character", 7));
		cards.Add(new HelpCard("Misdirection", AffectedAbility.Movement, -2)); // Example movement hassle
		cards.Add(new ClueCard("Precious Photos", 1)); // Special clue, applies anywhere? Treat as +1 Inv? [cite: 94]
		cards.Add(new HassleCard("Two is Plenty, Sir!", AffectedAbility.Investigation, -1, "White Dragon"));
		cards.Add(new ClueCard("Replicants Don't Have Scales", 1, "Animoid Row"));
		cards.Add(new SuspectCard("Suspicious Character", 7));
		cards.Add(new HelpCard("Misdirection", AffectedAbility.Movement, -2)); // Example movement hassle
		cards.Add(new HelpCard("Spinner Patrol"));
		cards.Add(new HassleCard("And if the Machine Doesn't Work?", AffectedAbility.Detection, -1));
		cards.Add(new HassleCard("Distracted", AffectedAbility.Investigation, -1));
		cards.Add(new HelpCard("That's the Spirit!", AffectedAbility.Combat, 1));
		cards.Add(new HassleCard("Buzz Off", AffectedAbility.Investigation, -1, "Snake Pit"));
		cards.Add(new HassleCard("Time to Die!", AffectedAbility.Combat, -1));
		cards.Add(new HelpCard("The Ol' Magic"));
		cards.Add(new SuspectCard("Suspicious Character", 5));
		cards.Add(new HelpCard("Light Ground Traffic", AffectedAbility.Movement, 1)); // Example movement help
		cards.Add(new HelpCard("Desperate Leap"));
		cards.Add(new HassleCard("Darkness", AffectedAbility.Investigation, -1, "Bradbury Building"));
		cards.Add(new HelpCard("I Owe You One..."));
		cards.Add(new SuspectCard("Suspicious Character", 5));
		cards.Add(new HelpCard("Spinner Patrol"));
		cards.Add(new HassleCard("And if the Machine Doesn't Work?", AffectedAbility.Detection, -1));
		cards.Add(new SuspectCard("Suspicious Character", 7));
		cards.Add(new SuspectCard("Suspicious Character", 6));
		cards.Add(new HelpCard("Emergency Call", AffectedAbility.Detection, 2, "Eyeworks"));
		cards.Add(new HassleCard("Heavy Ground Traffic", AffectedAbility.Movement, -2)); // Example movement hassle
		cards.Add(new SuspectCard("Suspicious Character", 6));
		cards.Add(new HelpCard("Desperate Leap"));

		Console.WriteLine($"Initialized Draw Deck with {cards.Count} cards."); // Should be 55
	}

	public void InitializeReplicants() // 5 Replicants [cite: 188, 221]
	{
		cards.Add(new ReplicantCard("Roy Batty", 3));
		cards.Add(new ReplicantCard("Leon", 2));
		cards.Add(new ReplicantCard("Pris", 2));
		cards.Add(new ReplicantCard("Zhora", 1));
		cards.Add(new ReplicantCard("Rachael", 1));
	}

	public void Shuffle()
	{
		int n = cards.Count;
		while (n > 1) {
			n--;
			int k = rng.Next(n + 1);
			Card value = cards[k];
			cards[k] = cards[n];
			cards[n] = value;
		}
	}

	public Card Draw() {
		if (IsEmpty) return null;
		Card card = cards[0];
		cards.RemoveAt(0);
		return card;
	}
	public void Add(Card card) {
		if (card != null) cards.Add(card);    // For discard pile
	}
}

/// <summary>
/// Represents a player (human or AI) in the game.
/// </summary>
public class Player
{
	// Properties... (Name, Color, Skills, Hand, Location, Status flags, etc.)
	public string Name { get; set; }
	public string Color { get; set; }
	public int Investigation { get; set; }
	public int Detection { get; set; }
	public int Combat { get; set; }
	public List<Card> Hand { get; set; }
	public string CurrentLocation { get; set; }
	public string HomeLocation { get; set; }
	public bool IsSympathizer { get; set; }
	public List<ReplicantCard> RetiredReplicants { get; set; }
	public List<ReplicantCard> RescuingReplicants { get; set; }
	public bool IsInCombat { get; set; }
	public Card CombatTarget { get; set; } // For Replicant combat
	public Player PlayerCombatTarget { get; set; } // For Player combat
	public bool IsAlive { get; set; }

	private const int MaxHandSize = 5; // Rule [cite: 199]

	public Player(string name, string color, string home)
	{
		Name = name;
		Color = color;
		HomeLocation = home;
		CurrentLocation = home;
		Hand = new List<Card>();
		RetiredReplicants = new List<ReplicantCard>();
		RescuingReplicants = new List<ReplicantCard>();
		IsSympathizer = false;
		IsInCombat = false;
		IsAlive = true;
	}

	public void SetSkills(int inv, int det, int com)
	{
		if (inv + det + com != 6 || inv < 1 || det < 1 || com < 1 || inv > 4 || det > 4 || com > 4) // Rule [cite: 248]
		{
			Console.WriteLine($"Warning: Invalid skills for {Name} ({inv},{det},{com}). Rule [cite: 248]");
		}
		Investigation = inv;
		Detection = det;
		Combat = com;
	}

	public void DrawCards(Deck deck, int count)
	{
		int actualDraw = Math.Min(count, MaxHandSize - Hand.Count);
		if (actualDraw <= 0) return;
		Console.WriteLine($"{Name} draws {actualDraw} cards.");
		for (int i = 0; i < actualDraw; i++) {
			Card drawnCard = deck.Draw();
			if (drawnCard != null) {
				Hand.Add(drawnCard);
				Console.WriteLine($" - Drew {drawnCard}");
				if (drawnCard is ReplicantCard && !IsSympathizer) Console.WriteLine($"* {Name} drew Replicant {drawnCard.Name}! Decision pending... *");
			} else {
				Console.WriteLine("Deck empty.");
				break;
			}
		}
	}

	public void DiscardCard(Card card, Deck discardPile)
	{
		if (card != null && Hand.Remove(card)) {
			discardPile.Add(card);
			Console.WriteLine($"{Name} discarded {card.Name}.");
		}
	}

	public void BecomeSympathizer(ReplicantCard replicant)
	{
		if (!IsSympathizer) {
			Console.WriteLine($"{Name} becomes a Sympathizer to rescue {replicant.Name}!");
			IsSympathizer = true;
			if(RetiredReplicants.Any()) {
				Console.WriteLine($"{Name}'s retired Replicants Out-of-Play. [cite: 289]");
				RetiredReplicants.Clear();
			}
			if (Hand.Remove(replicant)) RescuingReplicants.Add(replicant);
			else Console.WriteLine($"Warning: Replicant {replicant.Name} not in hand?");
			Console.WriteLine($"{Name} must reach {HomeLocation}. [cite: 290]");
		}
	}

	// Die method includes recycling as requested, with rule deviation notes
	public void Die(Game game)
	{
		Console.WriteLine($"{Name} has been killed!");
		IsAlive = false;
		IsInCombat = false;
		CombatTarget = null;
		PlayerCombatTarget = null; // Reset combat state

		if (IsSympathizer) { // Rule [cite: 284]
			Console.WriteLine($"{Name} was Sympathizer, OUT OF GAME. [cite: 284]");
			Console.WriteLine($"Hand recycled to Discard Pile.");
			foreach (var card in Hand) {
				game.DiscardPile.Add(card);
			}
			Hand.Clear();
			if(RescuingReplicants.Any()) {
				Console.WriteLine($"Rescuing Replicants recycled to Discard (House Rule/Deviation from [cite: 284]).");
				foreach (var rep in RescuingReplicants) {
					game.DiscardPile.Add(rep);
				}
			}
			RescuingReplicants.Clear();
			// Player stays dead (IsAlive = false)
		} else { // Blade Runner death [cite: 112]
			Console.WriteLine($"Hand recycled to Discard Pile. [cite: 112]");
			foreach (var card in Hand) {
				game.DiscardPile.Add(card);
			}
			Hand.Clear();
			//if(RetiredReplicants.Any()) {
			//	Console.WriteLine($"Retired Replicants recycled to Discard (Rule Deviation: should be Out-of-Play [cite: 112]).");
			//	foreach (var rep in RetiredReplicants) {
			//		game.DiscardPile.Add(rep);
			//	}
			//	RetiredReplicants.Clear();
			//}
			Console.WriteLine($"{Name} respawns at {HomeLocation} next turn. [cite: 112]");
			CurrentLocation = HomeLocation;
			// IsAlive is false, GameLoop handles skipping turn and setting back to true
			IsAlive = true;
		}
	}
}

#endregion Core Game Classes


// ####################################################
// ########            AI AGENT CLASSES        ########
// ####################################################

#region AI Agent Classes

// --- Game State Representation ---
public class GameState // Snapshot for Agent decision making
{
	public Player AgentPlayer { get; }
	public List<Card> AgentHand { get; } // Copy
	public List<PlayerInfo> OpponentInfos { get; }
	public Dictionary<string, List<Card>> CardsAtLocations { get; } // Replicants in combat primarily
	public int DrawDeckSize { get; }
	public int ReplicantDeckSize { get; }
	public GamePhase CurrentPhase { get; }

	public GameState(Player agentPlayer, Game game, GamePhase phase) {
		AgentPlayer = agentPlayer;
		AgentHand = new List<Card>(agentPlayer.Hand);
		OpponentInfos = game.Players.Where(p => p != agentPlayer).Select(p => new PlayerInfo(p)).ToList();
		CardsAtLocations = new Dictionary<string, List<Card>>();
		foreach (var p in game.Players.Where(p => p.IsAlive)) {
			if (!CardsAtLocations.ContainsKey(p.CurrentLocation)) CardsAtLocations[p.CurrentLocation] = new List<Card>();
			if (p.IsInCombat && p.CombatTarget is ReplicantCard rep && !CardsAtLocations[p.CurrentLocation].Contains(rep)) CardsAtLocations[p.CurrentLocation].Add(rep);
		}
		DrawDeckSize = game.DrawDeck.Count;
		ReplicantDeckSize = game.ReplicantDeck.Count;
		CurrentPhase = phase;
	}
}

public class PlayerInfo // Safe info about other players
{
	public string Name { get; } public string Color { get; } public string CurrentLocation { get; }
	public int HandSize { get; } public int Investigation { get; } public int Detection { get; } public int Combat { get; }
	public bool IsSympathizer { get; } public int RetiredCount { get; } public bool IsInCombat { get; }
	public PlayerInfo(Player player) {
		Name = player.Name;
		Color = player.Color;
		CurrentLocation = player.CurrentLocation;
		HandSize = player.Hand.Count;
		Investigation = player.Investigation;
		Detection = player.Detection;
		Combat = player.Combat;
		IsSympathizer = player.IsSympathizer;
		RetiredCount = player.RetiredReplicants.Count;
		IsInCombat = player.IsInCombat;
	}
}

// Enum for context
public enum GamePhase { Setup, Move, Investigation, Detection, CombatInitiation, CombatResolution, Discard, SympathizerDecision }

// --- Agent Controller Interface ---
public interface IAgentController
{
    // (Existing methods...)
    Tuple<int, int, int> ChooseSkills(Player agentPlayer);
    string ChooseMoveDestination(Player agentPlayer, int moveRoll, List<string> reachableLocations, GameState currentState, Func<string, string, int> getDistanceFunc);
    SuspectCard ChooseSuspectToTest(Player agentPlayer, GameState currentState);
    Player ChoosePlayerToAttack(Player agentPlayer, List<Player> potentialTargets, GameState currentState);
    Card ChooseCardToPlay(Player agentPlayer, GamePhase currentPhase, List<Card> applicableCards, GameState currentState); // For self/active action
    List<Card> ChooseCardsToDiscard(Player agentPlayer, GameState currentState);
    bool DecideToBecomeSympathizer(Player agentPlayer, ReplicantCard drawnReplicant, GameState currentState);

    // *** NEW METHOD ***
    /// <summary>
    /// Decide which Hassle card (if any) to play on the targetPlayer who is performing an action.
    /// </summary>
    /// <returns>The HassleCard to play, or null to play nothing.</returns>
    HassleCard ChooseHassleToPlay(Player agentPlayer, Player targetPlayer, AffectedAbility ability, string targetLocation, List<HassleCard> applicableHassles, GameState currentState);
}

// --- Revised SimpleRuleBasedAgent Class ---

public class SimpleRuleBasedAgent : IAgentController
	{
    private Random rng = new Random();

    // --- *** NEW METHOD IMPLEMENTATION *** ---
    public HassleCard ChooseHassleToPlay(Player agentPlayer, Player targetPlayer, AffectedAbility ability, string targetLocation, List<HassleCard> applicableHassles, GameState currentState)
{
	Console.WriteLine($"[AI-{agentPlayer.Name}] Considering playing Hassle on {targetPlayer.Name} for {ability} at {targetLocation}...");

	if (!applicableHassles.Any())
	{
		// Console.WriteLine($"[AI-{agentPlayer.Name}] No applicable Hassles found."); // Noisy
		return null;
	}

	// Simple AI Strategy: Play the first applicable Hassle found.
	// (More advanced AI could check target's skills, strategic importance, etc.)
	HassleCard hassleToPlay = applicableHassles.First();

	Console.WriteLine($"[AI-{agentPlayer.Name}] Choosing to play Hassle: {hassleToPlay.Name} on {targetPlayer.Name}.");
	return hassleToPlay;
}


// --- ChooseSkills remains the same ---
public Tuple<int, int, int> ChooseSkills(Player agentPlayer) {
	Console.WriteLine($"[AI-{agentPlayer.Name}] Choosing skills (2,2,2).");
	return Tuple.Create(2, 2, 2);
}

// --- ChooseMoveDestination remains the same ---
public string ChooseMoveDestination(Player agentPlayer, int moveRoll, List<string> reachableLocations, GameState currentState, Func<string, string, int> getDistanceFunc) {
	Console.WriteLine($"[AI-{agentPlayer.Name}] Choosing destination (Roll: {moveRoll})...");
	if (!reachableLocations.Any()) {
		Console.WriteLine($"[AI-{agentPlayer.Name}] No reachable locations.");
		return null;
	}
	if (agentPlayer.IsSympathizer) {
		/* ... Move towards home logic ... */ int currentDistToHome = getDistanceFunc(agentPlayer.CurrentLocation, agentPlayer.HomeLocation);
		var closerToHome = reachableLocations.Select(loc => new {
			Name = loc, Dist = getDistanceFunc(loc, agentPlayer.HomeLocation)
		}).Where(m => m.Dist < currentDistToHome && m.Dist != int.MaxValue).OrderBy(m => m.Dist).FirstOrDefault();
		if (closerToHome != null) {
			Console.WriteLine($"[AI-{agentPlayer.Name}] Moving towards Home: {closerToHome.Name}");
			return closerToHome.Name;
		}
	}
	string randomDest = reachableLocations[rng.Next(reachableLocations.Count)];
	Console.WriteLine($"[AI-{agentPlayer.Name}] Moving randomly to: {randomDest}");
	return randomDest;
}

// --- ChooseSuspectToTest remains the same ---
public SuspectCard ChooseSuspectToTest(Player agentPlayer, GameState currentState) {
	var suspects = currentState.AgentHand.OfType<SuspectCard>().OrderBy(s => s.Evasion).ToList();
	if (!suspects.Any()) return null;
	if (3 + agentPlayer.Detection >= suspects.First().Evasion) {
		Console.WriteLine($"[AI-{agentPlayer.Name}] Testing Suspect: {suspects.First().Name}");
		return suspects.First();
	}
	return null;
}

// --- ChoosePlayerToAttack remains the same ---
public Player ChoosePlayerToAttack(Player agentPlayer, List<Player> potentialTargets, GameState currentState) {
	if (!potentialTargets.Any()) return null;
	var sympathizers = potentialTargets.Where(p => p.IsSympathizer).ToList();
	if (sympathizers.Any()) {
		var target = sympathizers.First();
		if (agentPlayer.Combat >= target.Combat) {
			Console.WriteLine($"[AI-{agentPlayer.Name}] Attacking Sympathizer: {target.Name}");
			return target;
		}
	}
	return null;
}

// --- **** REVISED ChooseCardToPlay **** ---
public Card ChooseCardToPlay(Player agentPlayer, GamePhase currentPhase, List<Card> applicableCards, GameState currentState)
{
	// AI logic to decide which card (if any) from the applicable list to play.
	// Simple strategy: Play the first beneficial (Help/Clue) card found. Avoid playing Hassles on self.
	Console.WriteLine($"[AI-{agentPlayer.Name}] Considering playing a card for {currentPhase}...");

	if (!applicableCards.Any())
	{
		// Console.WriteLine($"[AI-{agentPlayer.Name}] No applicable cards to play."); // Can be noisy
		return null;
	}

	// Prioritize beneficial cards (Help/Clue) over Hassles when playing for self
	Card bestCardToPlay = applicableCards.FirstOrDefault(c => c is HelpCard || c is ClueCard);

	if (bestCardToPlay != null)
	{
		Console.WriteLine($"[AI-{agentPlayer.Name}] Choosing to play: {bestCardToPlay.Name}");
		return bestCardToPlay;
	}

	// If only Hassles are applicable (unlikely in the self-play scenario, but possible), don't play them.
	// Add logic here if AI should play Hassles on opponents.
	Console.WriteLine($"[AI-{agentPlayer.Name}] Found only applicable Hassles, choosing not to play on self.");
	return null;
}


// --- **** REVISED ChooseCardsToDiscard **** ---
public List<Card> ChooseCardsToDiscard(Player agentPlayer, GameState currentState)
{
	Console.WriteLine($"[AI-{agentPlayer.Name}] Choosing cards to discard (Hand: {currentState.AgentHand.Count})...");
	List<Card> toDiscard = new List<Card>();
	List<Card> simulatedHand = new List<Card>(currentState.AgentHand);
	// Target hand size - make space to draw Investigation skill cards next turn
	int desiredHandSize = Math.Max(0, 5 - agentPlayer.Investigation); // Leave space for Investigation draw

	while (simulatedHand.Count > desiredHandSize)
	{
		Card cardToConsider = null;
		int initialCount = simulatedHand.Count;

		// --- Discard Priority Logic ---

		// 1. Hassles IF at Police HQ (Rule)
		if (agentPlayer.CurrentLocation == "Police HQ") {
			cardToConsider = simulatedHand.OfType<HassleCard>().FirstOrDefault();
			if (cardToConsider != null) goto CardFound_Discard;
		}

		// 2. Replicant IF NOT Sympathizing (Fix the "Leak")
		if (!agentPlayer.IsSympathizer) {
			cardToConsider = simulatedHand.OfType<ReplicantCard>().FirstOrDefault();
			if (cardToConsider != null) {
				Console.WriteLine($"[AI-{agentPlayer.Name}] Prioritizing discard of Replicant {cardToConsider.Name} (not Sympathizer).");
				goto CardFound_Discard;
			}
		}

		// 3. Clues (Simple: Discard any Clue - could be improved with distance heuristic)
		cardToConsider = simulatedHand.OfType<ClueCard>().FirstOrDefault();
		if (cardToConsider != null) goto CardFound_Discard;

		// 4. Weakest Suspect (lowest Evasion)
		cardToConsider = simulatedHand.OfType<SuspectCard>().OrderBy(s => s.Evasion).FirstOrDefault();
		if (cardToConsider != null) goto CardFound_Discard;

		// 5. Non-essential Help cards (Keep combat helps if Combat is decent?)
		if (agentPlayer.Combat < 3) // If combat is low, maybe discard combat helps too
			cardToConsider = simulatedHand.OfType<HelpCard>().FirstOrDefault();
		else // Otherwise, keep combat helps, discard others
			cardToConsider = simulatedHand.OfType<HelpCard>().FirstOrDefault(h => h.AbilityAffected != AffectedAbility.Combat); // Keep combat helps
		if (cardToConsider != null) goto CardFound_Discard;

		// 6. Hassles - ONLY IF AT POLICE HQ (This check is now redundant due to #1, but harmless)
		// *** The problematic logic allowing discard anywhere else is REMOVED ***
		// if (cardToConsider == null && agentPlayer.CurrentLocation != "Police HQ") {
		//     // DO NOT DISCARD HASSLES HERE
		// }

		// 7. Last Resort: Discard anything left (except maybe the Replicant if Sympathizer)
		if (agentPlayer.IsSympathizer) {
			cardToConsider = simulatedHand.FirstOrDefault(c => !(c is ReplicantCard)); // Avoid discarding the rescued one
		}
		if (cardToConsider == null) { // If still nothing, or not sympathizer, grab first available
			cardToConsider = simulatedHand.FirstOrDefault();
		}

CardFound_Discard: // Label for goto jump

		if (cardToConsider != null) {
			toDiscard.Add(currentState.AgentHand.First(c => c == cardToConsider)); // Use original ref
			simulatedHand.Remove(cardToConsider); // Remove from temp list
			Console.WriteLine($"[AI-{agentPlayer.Name}] Planning to discard: {cardToConsider.Name}");
		} else {
			Console.WriteLine($"[AI-{agentPlayer.Name}] Cannot find suitable card to discard further.");
			break; // Exit loop
		}
		if (simulatedHand.Count == initialCount && simulatedHand.Count > desiredHandSize) {
			Console.WriteLine($"[AI-{agentPlayer.Name}] Discard Warning: Loop stuck.");
			break; // Safety break
		}
	}
	return toDiscard;
}

// --- DecideToBecomeSympathizer remains the same ---
public bool DecideToBecomeSympathizer(Player agentPlayer, ReplicantCard drawnReplicant, GameState currentState) {
	int myRetiredCount = agentPlayer.RetiredReplicants.Count;
	int maxOpponentRetired = currentState.OpponentInfos.Any() ? currentState.OpponentInfos.Max(o => o.RetiredCount) : 0;
	if (maxOpponentRetired >= myRetiredCount + 2) {
		Console.WriteLine($"[AI-{agentPlayer.Name}] Becoming Sympathizer with {drawnReplicant.Name}!");
		return true;
	}
	return false;
}
}

#endregion AI Agent Classes


// ####################################################
// ########             GAME CLASS             ########
// ####################################################

#region Game Class

/// <summary>
/// Manages the overall game state and flow for Blade Runner: Rep-Detect.
/// </summary>
public class Game
{
	// --- Properties ---
	public List<Player> Players { get; set; }
	public Deck DrawDeck { get; set; }
	public Deck DiscardPile { get; set; }
	public Deck ReplicantDeck { get; set; }
	public List<string> Locations { get; set; } // All named locations + homes
	public bool IsGameReallyOver { get; private set; } // Game end flag

	private int currentPlayerIndex;
	private Random rng = new Random();
	private Dictionary<string, Dictionary<string, int>> locationDistances; // Stores distances
	private Dictionary<string, IAgentController> playerControllers; // Maps Player Name -> AI Controller (null if Human)

	// --- Constructor ---
	public Game(List<Player> players, Dictionary<string, IAgentController> controllers)
	{
		Players = players ?? throw new ArgumentNullException(nameof(players));
		playerControllers = controllers ?? throw new ArgumentNullException(nameof(controllers)); // Must provide map
		DrawDeck = new Deck(); // Assumes default initialization of cards
		DiscardPile = new Deck(true);
		ReplicantDeck = new Deck(true);
		ReplicantDeck.InitializeReplicants(); // Adds the 5 Replicants
		ReplicantDeck.Shuffle();
		DrawDeck.Shuffle();

		// Define locations [cite: 8]
		Locations = new List<string> {
			"Tyrell Corp", "Animoid Row", "Snake Pit", "Police HQ",
			"White Dragon", "Yukon Hotel", "Bradbury Building", "Chinatown", "Eyeworks"
		};
		Locations.AddRange(players.Select(p => p.HomeLocation)); // Add player homes

		InitializeLocationDistances(players); // Populate distance table (uses placeholders)

		currentPlayerIndex = 0; // Player 0 starts (rules state highest roll, simplified here)
		IsGameReallyOver = false;
	}

	// --- Initialization Methods ---

	/// <summary>
	/// Populates the location distance table. IMPORTANT: Uses placeholder logic.
	/// </summary>
	private void InitializeLocationDistances(List<Player> players) {
		locationDistances = new Dictionary<string, Dictionary<string, int>>();
		List<string> allLocations = new List<string>(Locations);
		// Placeholder logic - REPLACE WITH ACTUAL BOARD DISTANCES
		foreach (string loc1 in allLocations) {
			locationDistances[loc1] = new Dictionary<string, int>();
			foreach (string loc2 in allLocations) {
				if (loc1 == loc2) locationDistances[loc1][loc2] = 0;
				else {
					int placeholderDistance;
					int hash = Math.Abs(loc1.GetHashCode() ^ loc2.GetHashCode());
					if (loc1.Contains(" Home") && loc2.Contains(" Home")) placeholderDistance = 15;
					else if (loc1.Contains(" Home") || loc2.Contains(" Home")) placeholderDistance = (hash % 8) + 4;
					else placeholderDistance = (hash % 6) + 1;
					if (locationDistances.ContainsKey(loc2) && locationDistances[loc2].ContainsKey(loc1)) locationDistances[loc1][loc2] = locationDistances[loc2][loc1];
					else locationDistances[loc1][loc2] = placeholderDistance;
				}
			}
		}
		Console.WriteLine("Location distance table initialized (PLACEHOLDERS - REPLACE WITH ACTUAL!).");
	}
	public int GetDistance(string start, string end) { /* ... Lookup logic as before ... */
		if (locationDistances.TryGetValue(start, out var destinations) && destinations.TryGetValue(end, out int distance)) return distance;
		Console.WriteLine($"Warning: Distance lookup failed: {start} -> {end}.");
		return int.MaxValue;
	}
	/// <summary>
	/// Sets up player skills (via AI/Human input) and draws initial hands.
	/// </summary>
	private void SetupPlayers() {
		Console.WriteLine("\n--- Preparation Round ---");
		foreach (var player in Players) {
			Console.WriteLine($"\nSetting up {player.Name} ({player.Color})...");
			Tuple<int, int, int> skills;
			playerControllers.TryGetValue(player.Name, out var agentController);
			if (agentController != null) {
				skills = agentController.ChooseSkills(player); // AI chooses
			} else { // Human chooses
				Console.WriteLine($"Human {player.Name}, enter skills (Inv Det Com, e.g. '3 2 1' - must sum 6, range 1-4):");
				string input = Console.ReadLine();
				skills = ParseSkillsInput(input); // Uses helper to parse/validate
			}
			player.SetSkills(skills.Item1, skills.Item2, skills.Item3);
			Console.WriteLine($"{player.Name} Skills - Inv: {player.Investigation}, Det: {player.Detection}, Com: {player.Combat}");
			player.DrawCards(DrawDeck, player.Investigation); // Initial hand draw [cite: 79]
		}
		Console.WriteLine("\n--- Setup Complete ---");
	}

	// Helper to parse human skill input
	private Tuple<int,int,int> ParseSkillsInput(string input) {
		try {
			var parts = input?.Split(new[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries).Select(int.Parse).ToList();
			if (parts != null && parts.Count == 3) {
				int inv = parts[0];
				int det = parts[1];
				int com = parts[2];
				// Basic validation [cite: 78]
				if (inv >= 1 && inv <= 4 && det >= 1 && det <= 4 && com >= 1 && com <= 4 && (inv + det + com == 6)) {
					// TODO: Check for uniqueness against other players if needed
					return Tuple.Create(inv, det, com);
				} else Console.WriteLine("Invalid skills (Range 1-4, Sum must be 6).");
			} else Console.WriteLine("Invalid format (expecting 3 numbers separated by space/comma).");
		} catch {
			Console.WriteLine("Invalid input.");
		}
		Console.WriteLine("Using default skills (2,2,2).");
		return Tuple.Create(2,2,2);
	}

	// --- Core Game Flow ---
	public void StartGame() {
		Console.WriteLine("--- Blade Runner: Rep-Detect ---");
		SetupPlayers();
		GameLoop();
	}

	private void GameLoop() {
		while (!this.IsGameReallyOver) {
			Player currentPlayer = Players[currentPlayerIndex];
			playerControllers.TryGetValue(currentPlayer.Name, out var currentAgent);
			bool isAI = currentAgent != null;

			// Handle Respawn State [cite: 112]
			if (!currentPlayer.IsAlive) {
				Console.WriteLine($"\nSkipping turn for {currentPlayer.Name} (Respawning).");
				currentPlayer.IsAlive = true; // Becomes active *next* turn
				currentPlayer.CurrentLocation = currentPlayer.HomeLocation; // Ensure they are home
				Console.WriteLine($"{currentPlayer.Name} will be active next turn from {currentPlayer.HomeLocation}.");
			}
			// Handle Active Player Turn
			else {
				Console.WriteLine($"\n--- {currentPlayer.Name}'s Turn ({(isAI ? "AI" : "Human")}, {currentPlayer.Color}) ---");
				Console.WriteLine($"Loc: {currentPlayer.CurrentLocation}, Hand: {currentPlayer.Hand.Count}, Ret: {currentPlayer.RetiredReplicants.Count}, Res: {currentPlayer.RescuingReplicants.Count}, Combat: {currentPlayer.IsInCombat}");

				// Execute phases
				ExecuteMovePhase(currentPlayer, currentAgent);
				if (this.IsGameReallyOver) break;
				ExecuteInvestigationPhase(currentPlayer, currentAgent);
				if (this.IsGameReallyOver) break;
				ExecuteDetectionPhase(currentPlayer, currentAgent);
				if (this.IsGameReallyOver) break;
				ExecuteCombatPhase(currentPlayer, currentAgent);
				if (this.IsGameReallyOver) break;
				ExecuteDiscardPhase(currentPlayer, currentAgent);
				if (this.IsGameReallyOver) break;

				// Check Sympathizer Win [cite: 58, 127]
				if (currentPlayer.IsSympathizer && currentPlayer.CurrentLocation == currentPlayer.HomeLocation && !currentPlayer.IsInCombat) {
					Console.WriteLine($"\n{currentPlayer.Name} reached home as Sympathizer!");
					DeclareWinner(currentPlayer);
					break;
				}
			}

			// Check general game end conditions [cite: 59]
			if (!this.IsGameReallyOver && CheckForGameOver()) break;

			// Advance to next player if game hasn't ended
			if (!this.IsGameReallyOver) {
				AdvancePlayerTurn();
			}

			// Pause for readability
			if (!isAI || Players.Any(p => !playerControllers.ContainsKey(p.Name))) {
				Console.WriteLine("\nPress Enter to continue...");
				Console.ReadLine();
			}
			else {
				Thread.Sleep(1500); //Pause for AI vs. AI
			}
			//Force garbage collection
			//
			GC.Collect();
			GC.WaitForPendingFinalizers();
		}
		Console.WriteLine("--- Game Over ---");
	}

	// Helper to advance turn, skipping dead/respawning players
	private void AdvancePlayerTurn() {
		//int initialIndex = currentPlayerIndex;
		int loopCheck = 0;
		if (Players.Count(p => p.IsAlive) <= 0 && Players.Count > 1) { // Check if all players died somehow
			Console.WriteLine("All players are deceased! No winner.");
			this.IsGameReallyOver = true;
			return;
		}
		do {
			currentPlayerIndex = (currentPlayerIndex + 1) % Players.Count;
			loopCheck++;
		}
		// Loop while the selected player is NOT alive (still respawning), prevent infinite loop
		while (Players.Count > 0 && !Players[currentPlayerIndex].IsAlive && loopCheck <= Players.Count && Players.Count(p => p.IsAlive) > 0);

		if(loopCheck > Players.Count * 2) { // Safety break
			Console.WriteLine("Error: Could not find next active player!");
			this.IsGameReallyOver = true;
		}
	}


	// --- Turn Phase Methods ---

	private void ExecuteMovePhase(Player player, IAgentController agentController) {
		GameState currentState = new GameState(player, this, GamePhase.Move);
		if (player.IsInCombat) {
			Console.WriteLine($"{player.Name} in Combat, cannot move.");    // Rule [cite: 87]
			return;
		}
		if (player.IsSympathizer && player.CurrentLocation == player.HomeLocation) {
			Console.WriteLine($"{player.Name} Sympathizer stays put at Home.");    // Rule [cite: 120] implied
			return;
		}

		string chosenDestination = null;
		bool mustMove = player.CurrentLocation == player.HomeLocation && !player.IsSympathizer; // Rule [cite: 86]

		if (mustMove) { // Apply HOUSE RULE: Move to nearest non-home location
			Console.WriteLine($"{player.Name} must move from Home (House Rule: Nearest).");
			var potentialDestinations = Locations.Where(loc => !loc.EndsWith(" Home")).Select(loc => new {
				Name = loc, Dist = GetDistance(player.HomeLocation, loc)
			}).Where(m => m.Dist > 0 && m.Dist != int.MaxValue).OrderBy(m => m.Dist).ToList();
			if (potentialDestinations.Any()) {
				int nearestDistance = potentialDestinations.First().Dist;
				List<string> nearestLocations = potentialDestinations.Where(m => m.Dist == nearestDistance).Select(m => m.Name).ToList();
				if (nearestLocations.Count == 1) {
					chosenDestination = nearestLocations.First();
					Console.WriteLine($"{player.Name} moves to nearest: {chosenDestination} (Dist: {nearestDistance}).");
				}
				else {
					Console.WriteLine($"Tie for nearest (Dist: {nearestDistance}): {string.Join(", ", nearestLocations)}");
					if (agentController != null) {
						chosenDestination = nearestLocations.First();
						Console.WriteLine($"[AI-{player.Name}] chooses {chosenDestination}.");
					}
					else {
						/* Human choice */ Console.Write($"Choose destination #: ");
						if (int.TryParse(Console.ReadLine(), out int choice) && choice > 0 && choice <= nearestLocations.Count) chosenDestination = nearestLocations[choice - 1];
						else {
							chosenDestination = nearestLocations.First();
							Console.WriteLine("Invalid/No choice, defaulting.");
						}
					}
				}
			} else {
				Console.WriteLine($"Error: No non-home locations found from {player.HomeLocation}!");
			}
			if (!string.IsNullOrEmpty(chosenDestination)) player.CurrentLocation = chosenDestination;
			else Console.WriteLine($"{player.Name} could not move from Home.");
			return;
		}
		else { // Optional Move
			bool wantsToMove = false;
			if (agentController != null) {
				wantsToMove = true;
				Console.WriteLine($"[AI-{player.Name}] decides to roll.");
			}
			else {
				Console.Write("Roll die to move? (y/n): ");
				wantsToMove = (Console.ReadLine()?.ToLower() ?? "n") == "y";
			}
			if (wantsToMove) {
				int selfModifier = GetAndApplyModifiers(player, agentController, AffectedAbility.Movement, player.CurrentLocation, GamePhase.Move);
				int hassleModifier = ApplyOpponentHassles(player, AffectedAbility.Movement, player.CurrentLocation, GamePhase.Move);
				int totalModifier = selfModifier + hassleModifier;
				int roll = RollDie();
				int totalMovement = Math.Max(0, roll + totalModifier); // Allow reduction to 0
				Console.WriteLine($"{player.Name} rolls {roll}. Total Mod: {totalModifier:+0;-#}. Total movement: {totalMovement}");
				if (totalMovement == 0) {
					Console.WriteLine("Cannot move.");
					return;
				}
				var possibleMoves = locationDistances[player.CurrentLocation].Where(kvp => kvp.Value > 0 && kvp.Value <= totalMovement).OrderBy(kvp => kvp.Value).ToList();
				List<string> reachable = possibleMoves.Select(kvp => kvp.Key).ToList();
				if (!reachable.Any()) {
					Console.WriteLine("No locations reachable.");
					return;
				}
				if (agentController != null) {
					chosenDestination = agentController.ChooseMoveDestination(player, totalMovement, reachable, currentState, GetDistance);    // AI chooses
				}
				else {
					Console.WriteLine("Reachable:");    // Human chooses
					foreach(var move in possibleMoves) Console.WriteLine($"- {move.Key} (Dist: {move.Value})");
					Console.Write("Enter destination (or Enter to stay): ");
					string inputDest = Console.ReadLine();
					if (!string.IsNullOrWhiteSpace(inputDest) && reachable.Contains(inputDest)) chosenDestination = inputDest;
				}
				if (!string.IsNullOrEmpty(chosenDestination)) {
					Console.WriteLine($"{player.Name} moves to {chosenDestination}.");
					player.CurrentLocation = chosenDestination;
				}
				else {
					Console.WriteLine($"{player.Name} stays put.");
				}
			} else {
				Console.WriteLine($"{player.Name} chooses not to move.");
			}
		}
	}

	private void ExecuteInvestigationPhase(Player player, IAgentController agentController) {
		bool canInvestigate = Locations.Contains(player.CurrentLocation) && player.CurrentLocation != "Police HQ";
		if (player.IsSympathizer && player.CurrentLocation == player.HomeLocation) canInvestigate = true; // Rule [cite: 94] and Sympathizer home exception implied
		if (!canInvestigate) return;
		Console.WriteLine($"Investigation Phase at {player.CurrentLocation}.");
		int selfModifier = GetAndApplyModifiers(player, agentController, AffectedAbility.Investigation, player.CurrentLocation, GamePhase.Investigation);
		int hassleModifier = ApplyOpponentHassles(player, AffectedAbility.Investigation, player.CurrentLocation, GamePhase.Investigation);
		int totalModifier = selfModifier + hassleModifier;
		int effectiveInvestigation = Math.Max(0, player.Investigation + totalModifier);
		Console.WriteLine($"Base Inv: {player.Investigation}. Total Mod: {totalModifier:+0;-#}. Effective: {effectiveInvestigation}");
		int cardsToDraw = effectiveInvestigation;
		int actualDraw = Math.Min(cardsToDraw, 5 - player.Hand.Count); // Rule [cite: 93] Hand limit 5
		if (actualDraw > 0) {
			player.DrawCards(DrawDeck, actualDraw);    // Rule [cite: 15] reshuffle
			if(DrawDeck.IsEmpty && actualDraw > 0 && player.Hand.Count < 5 && DiscardPile.cards.Count > 0) {
				Console.WriteLine("Reshuffling discard...");
				DrawDeck.cards.AddRange(DiscardPile.cards);
				DiscardPile.cards.Clear();
				DrawDeck.Shuffle();
				player.DrawCards(DrawDeck, Math.Min(cardsToDraw, 5 - player.Hand.Count));
			}
		}
		else if (cardsToDraw > 0) Console.WriteLine($"Hand limit reached or effective Inv is 0.");
	}

// --- ExecuteDetectionPhase in Game Class with Extended Workaround ---

    private void ExecuteDetectionPhase(Player player, IAgentController agentController)
    {
        GameState currentState = new GameState(player, this, GamePhase.Detection);
        // Basic checks: cannot detect if in combat, must be at a location [cite: 96]
        if (player.IsInCombat || !Locations.Contains(player.CurrentLocation) || (player.CurrentLocation.EndsWith(" Home") && !player.IsSympathizer)) return;

        var suspectsInHand = player.Hand.OfType<SuspectCard>().ToList();
        if (!suspectsInHand.Any()) return; // No suspects to test

        SuspectCard suspectToTest = null;
        // --- Logic for AI/Human choosing suspect (as established before) ---
        if (agentController != null)
        {
            suspectToTest = agentController.ChooseSuspectToTest(player, currentState);
        }
        else
        { // Human Chooses Suspect
            Console.WriteLine("Detection Phase: Choose Suspect to test:");
            for (int i = 0; i < suspectsInHand.Count; i++) Console.WriteLine($"{i + 1}: {suspectsInHand[i]}"); // Uses ToString override
            Console.WriteLine("0: Skip Detection");
            Console.Write("Enter choice: ");
            if (int.TryParse(Console.ReadLine(), out int choice) && choice > 0 && choice <= suspectsInHand.Count)
            {
                suspectToTest = suspectsInHand[choice - 1];
            }
        }
        // --- End Suspect Choice ---

        if (suspectToTest != null)
        {
            player.Hand.Remove(suspectToTest); // Play the suspect
            Console.WriteLine($"{player.Name} tests {suspectToTest.Name} at {player.CurrentLocation}.");
            DiscardPile.Add(suspectToTest); // Suspect is always discarded after test [cite: 97, 99]

            // Apply card effects on Detection (as established before)
            int selfModifier = GetAndApplyModifiers(player, agentController, AffectedAbility.Detection, player.CurrentLocation, GamePhase.Detection);
            int hassleModifier = ApplyOpponentHassles(player, AffectedAbility.Detection, player.CurrentLocation, GamePhase.Detection);
            int totalModifier = selfModifier + hassleModifier;
            int effectiveDetectionSkill = player.Detection + totalModifier;

            Console.WriteLine($"{player.Name}'s base Detection: {player.Detection}. Total Mod: {totalModifier:+0;-#}. Effective: {effectiveDetectionSkill}");
            int detectionRoll = RollDie();
            int totalDetection = detectionRoll + effectiveDetectionSkill;
            Console.WriteLine($"Roll: {detectionRoll} + Effective Skill: {effectiveDetectionSkill} = Total: {totalDetection}");

            if (totalDetection >= suspectToTest.Evasion) // Test Successful [cite: 98]
            {
                Console.WriteLine($"Detection successful! (>= {suspectToTest.Evasion}). Checking Human/Replicant...");
                int replicantCheckRoll = RollDie();
                Console.WriteLine($"Replicant Check Roll: {replicantCheckRoll} (Need 4-6 for Replicant)"); // [cite: 99]

                if (replicantCheckRoll >= 4) // REPLICANT Indicated!
                {
                    Console.WriteLine($"Result: REPLICANT indicated!");
                    Card drawnReplicantCard = ReplicantDeck.Draw(); // Try drawing from the dedicated deck FIRST

                    // --- EXTENDED WORKAROUND LOGIC ---
                    if (drawnReplicantCard == null) // If Replicant Deck is empty...
                    {
                        Console.WriteLine("Replicant Deck empty. Checking Discard Pile for escaped Replicants (House Rule)...");
                        drawnReplicantCard = DiscardPile.cards.FirstOrDefault(c => c is ReplicantCard);

                        if (drawnReplicantCard != null)
                        {
                            Console.WriteLine($"Found escaped Replicant {drawnReplicantCard.Name} in Discard Pile! Removing it.");
                            DiscardPile.cards.Remove(drawnReplicantCard); // Remove it from discard
                        }
                        else
                        {
                            Console.WriteLine("No Replicants found in Discard Pile. Checking main Draw Deck (Further House Rule)...");
                            drawnReplicantCard = DrawDeck.cards.FirstOrDefault(c => c is ReplicantCard);

                            if (drawnReplicantCard != null)
                            {
                                Console.WriteLine($"Found Replicant {drawnReplicantCard.Name} in Draw Deck! Removing it.");
                                DrawDeck.cards.Remove(drawnReplicantCard); // Remove it from Draw Deck
                            }
                            else
                            {
                                Console.WriteLine("No Replicants found in Discard Pile or Draw Deck.");
                                // No Replicant appears this turn despite successful detection
                            }
                        }
                    }
                    // --- END EXTENDED WORKAROUND LOGIC ---


                    // --- Initiate Combat (if a Replicant was found/drawn) ---
                    if (drawnReplicantCard != null && drawnReplicantCard is ReplicantCard replicantForCombat)
                    {
                        Console.WriteLine($"A wild {replicantForCombat.Name} appears!");
                        player.IsInCombat = true;
                        player.CombatTarget = replicantForCombat; // Assign the found/drawn replicant
                        player.PlayerCombatTarget = null; // Ensure player target clear
                        Console.WriteLine($"{player.Name} enters Combat with {replicantForCombat.Name}!");
                    }
                    // If drawnReplicantCard is still null here, nothing happens.

                }
                else // HUMAN indicated [cite: 98]
                {
                    Console.WriteLine("Result: Human.");
                    // Suspect already discarded earlier
                }
            }
            else // Test Failed [cite: 97]
            {
                Console.WriteLine($"Detection failed! (< {suspectToTest.Evasion}).");
                // Suspect already discarded earlier
            }
        }
    } // End ExecuteDetectionPhase

	private void InitiatePlayerCombat(Player attacker, IAgentController agentController) {
		//Allows attacking suspected sympathizer
		GameState currentState = new GameState(attacker, this, GamePhase.CombatInitiation);
		if (attacker.IsSympathizer || attacker.IsInCombat) return; // Can't attack if sympathizer or already fighting
		List<Player> potentialTargets = Players.Where(p => p != attacker && p.IsAlive).ToList();
		if (!potentialTargets.Any()) return;

		Player defender = null;
		if (agentController != null) {
			defender = agentController.ChoosePlayerToAttack(attacker, potentialTargets, currentState);    // AI choice
		}
		else {
			/* Human choice */ Console.WriteLine($"\n{attacker.Name}, potential player combat targets:");
			Dictionary<int, Player> targetMap = new Dictionary<int, Player>();
			int targetIndex = 1;
			foreach (var target in potentialTargets) {
				string status = target.IsSympathizer ? "Declared Sympathizer" : "Blade Runner";
				Console.WriteLine($"{targetIndex}: {target.Name} ({status}) at {target.CurrentLocation}");
				targetMap.Add(targetIndex, target);
				targetIndex++;
			}
			Console.WriteLine("0: Attack no one");
			Console.Write("Choose target #: ");
			if (int.TryParse(Console.ReadLine(), out int choice) && choice > 0 && targetMap.ContainsKey(choice)) defender = targetMap[choice];
		}

		if (defender != null) {
			Console.WriteLine($"{attacker.Name} initiates combat with {defender.Name}!");
			attacker.IsInCombat = true;
			attacker.PlayerCombatTarget = defender;
			attacker.CombatTarget = null;
			defender.IsInCombat = true;
			defender.PlayerCombatTarget = attacker;
			defender.CombatTarget = null; // Set combat state
			if (!defender.IsSympathizer) {
				Console.WriteLine($"WARNING: Attacking Blade Runner {defender.Name}! Risk of Murder! [cite: 135]");    // Murder rule warning
			}
		}
	}

	private void ExecuteCombatPhase(Player player, IAgentController agentController) {
		if (!player.IsInCombat) InitiatePlayerCombat(player, agentController); // Offer initiation
		if (this.IsGameReallyOver || !player.IsInCombat) return; // Check if still in combat / game ended

		//GameState currentState = new GameState(player, this, GamePhase.CombatResolution);
		int playerSelfModifier = GetAndApplyModifiers(player, agentController, AffectedAbility.Combat, player.CurrentLocation, GamePhase.CombatResolution); // Rule [cite: 100] allows mods
		int playerHassleModifier = ApplyOpponentHassles(player, AffectedAbility.Combat, player.CurrentLocation, GamePhase.CombatResolution);
		int playerTotalModifier = playerSelfModifier + playerHassleModifier;
		int opponentTotalModifier = 0; // Simplified: Opponent mods not implemented here

		// Resolve Player-vs-Player Combat Sympathizer combat, Suspected Sympathizer combat
		if (player.PlayerCombatTarget != null) {
			Player opponentPlayer = player.PlayerCombatTarget;
			Console.WriteLine($"Combat: {player.Name} vs Player {opponentPlayer.Name}");
			int effPCom = player.Combat + playerTotalModifier;
			int effOCom = opponentPlayer.Combat + opponentTotalModifier;
			int pRoll = RollDie();
			int pTotal = pRoll + effPCom;
			int oRoll = RollDie();
			int oTotal = oRoll + effOCom;
			Console.WriteLine($"{player.Name} ({player.Combat}{playerTotalModifier:+0;-#}) roll {pRoll} -> {pTotal}");
			Console.WriteLine($"{opponentPlayer.Name} ({opponentPlayer.Combat}{opponentTotalModifier:+0;-#}) roll {oRoll} -> {oTotal}");
			if (pTotal > oTotal) {
				Console.WriteLine($"{player.Name} WINS vs {opponentPlayer.Name}!");    // Player wins P-vs-P
				bool murder = false;
				if (!opponentPlayer.IsSympathizer) {
					bool hadRep = opponentPlayer.Hand.OfType<ReplicantCard>().Any();
					if (!hadRep) {
						Console.WriteLine($"MURDER! {player.Name} OUT!");
						player.IsAlive = false;
						murder = true;
						opponentPlayer.IsAlive = true;
						opponentPlayer.CurrentLocation = opponentPlayer.HomeLocation;
						opponentPlayer.Hand.Clear();
						Console.WriteLine($"{opponentPlayer.Name} restarts.");
					}
					else {
						Console.WriteLine($"Kill justified.");
						opponentPlayer.Die(this); /* Claim kill? */
					}
				}
				else {
					opponentPlayer.Die(this); /* Claim kill? */
				}
				if (!murder) {
					player.IsInCombat = false;
					player.PlayerCombatTarget = null;
				}
				opponentPlayer.IsInCombat = false;
				opponentPlayer.PlayerCombatTarget = null;
			}
			else if (oTotal > pTotal) {
				Console.WriteLine($"{player.Name} LOSES vs {opponentPlayer.Name}!");    // Player loses P-vs-P
				player.Die(this);
				opponentPlayer.IsInCombat = false;
				opponentPlayer.PlayerCombatTarget = null;
			}
			else {
				Console.WriteLine("Player Combat TIE!");    // Tie P-vs-P
			}
		}
		// Resolve Player-vs-Replicant Combat
		else if (player.CombatTarget is ReplicantCard replicant) {
			Console.WriteLine($"Combat: {player.Name} vs Replicant {replicant.Name}");
			int effPCom = player.Combat + playerTotalModifier;
			int effOCom = replicant.Combat + opponentTotalModifier;
			int pRoll = RollDie();
			int pTotal = pRoll + effPCom;
			int oRoll = RollDie();
			int oTotal = oRoll + effOCom;
			Console.WriteLine($"{player.Name} ({player.Combat}{playerTotalModifier:+0;-#}) roll {pRoll} -> {pTotal}");
			Console.WriteLine($"{replicant.Name} ({replicant.Combat}{opponentTotalModifier:+0;-#}) roll {oRoll} -> {oTotal}");
			if (pTotal > oTotal) {
				Console.WriteLine($"{player.Name} WINS! {replicant.Name} retired!");    // Player wins P-vs-R[cite: 102], check win con [cite: 57]
				bool wasBRRetire = false;
				if (!player.IsSympathizer) {
					player.RetiredReplicants.Add(replicant);
					wasBRRetire = true;
				}
				else {
					Console.WriteLine("Sympathizer retired Rep.");
					player.RetiredReplicants.Add(replicant);
				}
				player.IsInCombat = false;
				player.CombatTarget = null;
				if (wasBRRetire) {
					int totalBRRetires = Players.Where(p => p.IsAlive && !p.IsSympathizer).Sum(p => p.RetiredReplicants.Count);
					Console.WriteLine($"Total BR retires: {totalBRRetires}");
					if (totalBRRetires == 5 && !Players.Any(p => p.IsAlive && p.IsSympathizer)) {
						Console.WriteLine("5th Replicant retired! Checking scores...");
						DeclareWinnerByRetirement();
					}
					else if (totalBRRetires == 5) Console.WriteLine("5th Rep retired, but Sympathizers active.");
				}
			}
			else if (oTotal > pTotal) {
				Console.WriteLine($"{player.Name} LOSES!");    // Player loses P-vs-R [cite: 104, 105]
				player.Die(this);
				Console.WriteLine($"{replicant.Name} escapes!");
				DiscardPile.Add(replicant);
			}
			else {
				Console.WriteLine("Replicant Combat TIE!");    // Tie P-vs-R [cite: 103]
			}
		}
		// Cleanup
		else if (player.IsInCombat) {
			Console.WriteLine($"Warning: InCombat but no target.");
			player.IsInCombat = false;
			player.CombatTarget = null;
			player.PlayerCombatTarget = null;
		}
	}

	private void ExecuteDiscardPhase(Player player, IAgentController agentController) {
		GameState currentState = new GameState(player, this, GamePhase.Discard);
		Console.WriteLine("Discard Phase:");
		List<Card> cardsToDiscard = new List<Card>();
		if (agentController != null) cardsToDiscard = agentController.ChooseCardsToDiscard(player, currentState); // AI decides discards
		else {
			bool stillDiscarding = true;    // Human decides discards
			while (stillDiscarding && player.Hand.Count > 0) {
				Console.WriteLine("Hand:");
				for(int i=0; i<player.Hand.Count; i++) Console.WriteLine($"{i + 1}: {player.Hand[i]}");
				Console.Write("Card # to discard (0=Done): ");
				if (int.TryParse(Console.ReadLine(), out int choice) && choice > 0 && choice <= player.Hand.Count) {
					Card card = player.Hand[choice - 1];
					if (card is HassleCard && player.CurrentLocation != "Police HQ") {
						Console.WriteLine("Can only discard Hassles at Police HQ.");
						continue;
					} /* Rule [cite: 110] */ if (!player.IsSympathizer && card is ReplicantCard repCard) {
						Console.Write($"Become Sympathizer with {repCard.Name} instead? (y/n): ");
						if ((Console.ReadLine()?.ToLower() ?? "n") == "y") {
							player.BecomeSympathizer(repCard);
							continue;
						}
					}
					cardsToDiscard.Add(card);
					Console.WriteLine($"Marked {card.Name} for discard.");
				}
				else if (choice == 0) stillDiscarding = false;
				else Console.WriteLine("Invalid.");
			}
		}
		foreach (var card in cardsToDiscard) player.DiscardCard(card, DiscardPile);
		Console.WriteLine($"{player.Name} finishes discard with {player.Hand.Count} cards.");
		// Sympathizer decision point (if Replicant held after discards)
		var replicantsInHand = player.Hand.OfType<ReplicantCard>().ToList();
		if (!player.IsSympathizer && replicantsInHand.Any()) {
			GameState sympState = new GameState(player, this, GamePhase.SympathizerDecision);
			ReplicantCard repToConsider = replicantsInHand.First();
			bool becomeSymp = false;
			if(agentController != null) becomeSymp = agentController.DecideToBecomeSympathizer(player, repToConsider, sympState);
			else {
				Console.Write($"You hold {repToConsider.Name}. Become Sympathizer now? (y/n): ");
				becomeSymp = (Console.ReadLine()?.ToLower() ?? "n") == "y";
			}
			if (becomeSymp) player.BecomeSympathizer(repToConsider);
		}
	}

	// --- Modifier Application Helpers ---
	private int GetAndApplyModifiers(Player activePlayer, IAgentController agentController, AffectedAbility ability, string currentLocation, GamePhase phase) { /* ... As before ... */
		int totalModifier = 0;
		bool continuePlaying = true;
		while (continuePlaying) {
			continuePlaying = false; // Only one card per opportunity for now
			List<Card> applicableCards = activePlayer.Hand.Where(c => ((c is HelpCard hc && hc.AbilityAffected == ability && hc.ModifierAmount > 0) || (c is ClueCard cl && cl.AbilityAffected == ability && cl.ModifierAmount > 0) || (c is HassleCard hs && hs.AbilityAffected == ability && hs.ModifierAmount < 0))).Where(c => {
				string targetLoc = null;
				if (c is HelpCard hc) targetLoc = hc.TargetLocation;
				else if (c is ClueCard cl) targetLoc = cl.TargetLocation;
				else if (c is HassleCard hs) targetLoc = hs.TargetLocation;
				return string.IsNullOrEmpty(targetLoc) || targetLoc.Equals(currentLocation, StringComparison.OrdinalIgnoreCase);
			}).ToList();
			if (!applicableCards.Any()) break;
			GameState currentState = new GameState(activePlayer, this, phase);
			Card cardToPlay = null;
			if (agentController != null) {
				cardToPlay = agentController.ChooseCardToPlay(activePlayer, phase, applicableCards, currentState);    // AI choice
				if (cardToPlay != null && !applicableCards.Contains(cardToPlay)) {
					Console.WriteLine($"AI chose invalid card {cardToPlay.Name}");
					cardToPlay = null;
				}
			}
			else {
				Console.WriteLine($"-- Play Card for {ability} at {currentLocation}? --");    // Human choice
				Console.WriteLine("Applicable:");
				if (applicableCards.Any()) {
					for (int i = 0; i < applicableCards.Count; i++) Console.WriteLine($"{i + 1}: {applicableCards[i]}");
					Console.WriteLine("0: Play nothing");
					Console.Write($"Choice: ");
					if (int.TryParse(Console.ReadLine(), out int choice) && choice > 0 && choice <= applicableCards.Count) cardToPlay = applicableCards[choice - 1];
				}
				else Console.WriteLine("(None)");
			}
			if (cardToPlay != null) {
				int modifier = 0;
				if (cardToPlay is HelpCard hc) modifier = hc.ModifierAmount;
				else if (cardToPlay is ClueCard cl) modifier = cl.ModifierAmount;
				else if (cardToPlay is HassleCard hs) modifier = hs.ModifierAmount;
				Console.WriteLine($"{activePlayer.Name} plays {cardToPlay.Name} ({modifier:+0;-#} {ability})!");
				totalModifier += modifier;
				activePlayer.Hand.Remove(cardToPlay);
				DiscardPile.Add(cardToPlay); /* Add logic for multiple card plays? */
			}
		}
		return totalModifier;
	}
	private int ApplyOpponentHassles(Player targetPlayer, AffectedAbility ability, string targetLocation, GamePhase phase) { /* ... As before ... */
		int totalHassleModifier = 0;
		int startIndex = Players.IndexOf(targetPlayer);
		if (startIndex < 0) return 0; // Target player not found?
		for (int i = 1; i < Players.Count; i++) {
			int opponentIndex = (startIndex + i) % Players.Count;
			Player opponent = Players[opponentIndex];
			if (!opponent.IsAlive || opponent == targetPlayer) continue;
			List<HassleCard> applicableHassles = opponent.Hand.OfType<HassleCard>().Where(h => h.AbilityAffected == ability && h.ModifierAmount < 0).Where(h => string.IsNullOrEmpty(h.TargetLocation) || h.TargetLocation.Equals(targetLocation, StringComparison.OrdinalIgnoreCase)).ToList();
			if (!applicableHassles.Any()) continue;
			HassleCard hassleToPlay = null;
			playerControllers.TryGetValue(opponent.Name, out var opponentAgentController);
			if (opponentAgentController != null) {
				GameState opponentState = new GameState(opponent, this, phase);    // AI choice
				hassleToPlay = opponentAgentController.ChooseHassleToPlay(opponent, targetPlayer, ability, targetLocation, applicableHassles, opponentState);
				if (hassleToPlay != null && !applicableHassles.Contains(hassleToPlay)) {
					Console.WriteLine($"AI chose invalid Hassle.");
					hassleToPlay = null;
				}
			}
			else {
				Console.WriteLine($"--- {opponent.Name}, play Hassle on {targetPlayer.Name} for {ability} at {targetLocation}? ---");    // Human choice
				Console.WriteLine("Applicable Hassles:");
				for (int j = 0; j < applicableHassles.Count; j++) Console.WriteLine($"{j + 1}: {applicableHassles[j]}");
				Console.WriteLine("0: Play nothing");
				Console.Write($"Choice: ");
				if (int.TryParse(Console.ReadLine(), out int choice) && choice > 0 && choice <= applicableHassles.Count) hassleToPlay = applicableHassles[choice - 1];
			}
			if (hassleToPlay != null) {
				Console.WriteLine($"{opponent.Name} plays Hassle {hassleToPlay.Name} ({hassleToPlay.ModifierAmount:+0;-#}{ability}) on {targetPlayer.Name}!");
				totalHassleModifier += hassleToPlay.ModifierAmount;
				opponent.Hand.Remove(hassleToPlay);
				DiscardPile.Add(hassleToPlay);
			}
		}
		return totalHassleModifier;
	}

	// --- Game End Condition Checks and Declarations ---
	private bool CheckForGameOver() {
		/* ... Checks Last Man Standing[cite: 59]... */ if (Players.Count(p => p.IsAlive) <= 1 && Players.Count > 1) {
			if (!this.IsGameReallyOver) {
				Console.WriteLine("Last player standing wins!");
				DeclareWinner(Players.FirstOrDefault(p => p.IsAlive));
			}
			return true;
		}
		return this.IsGameReallyOver;
	}
	private void DeclareWinnerByRetirement() {
		/* ... Handles scores and ties correctly[cite: 57]... */ Console.WriteLine("\n--- Final Scores (Retirement Victory Triggered) ---");
		int maxRetired = -1;
		Console.WriteLine("Final Retirement Counts:");
		foreach (var p in Players) {
			string status = !p.IsAlive ? "(Deceased)" : (p.IsSympathizer ? "(Sympathizer)" : "");
			Console.WriteLine($"  - {p.Name} {status}: {p.RetiredReplicants.Count} retired");
		}
		Console.WriteLine("-------------------------------------------");
		foreach (var p in Players.Where(p => p.IsAlive && !p.IsSympathizer)) {
			int score = p.RetiredReplicants.Count;
			if (score > maxRetired) maxRetired = score;
		}
		if (maxRetired <= 0) Console.WriteLine("\n!!! Game Over: 5th Rep retired, but highest eligible score was 0. No winner by retirement. !!!");
		else {
			List<Player> winners = Players.Where(p => p.IsAlive && !p.IsSympathizer && p.RetiredReplicants.Count == maxRetired).ToList();
			if (winners.Count == 1) Console.WriteLine($"\n!!! {winners.First().Name} WINS (Most Retires: {maxRetired})! !!!");
			else {
				Console.WriteLine($"\n!!! TIE! Tied for most retires ({maxRetired}):");
				foreach (var w in winners) Console.WriteLine($"   - {w.Name}");
				Console.WriteLine("They share the victory! !!!");
			}
		}
		this.IsGameReallyOver = true;
	}
	private void DeclareWinner(Player winner) {
		/* ... Declares Sympathizer [cite: 58] or Last Standing [cite: 59] winner ... */ if (winner != null) {
			Console.Write($"\n!!! {winner.Name} ({winner.Color}) WINS");
			if(winner.IsSympathizer) Console.WriteLine($" (Sympathizer Escape)! !!!");
			else Console.WriteLine($" (Last Standing)! !!!");
		}
		else Console.WriteLine("\n!!! GAME OVER - Winner unclear? !!!");
		this.IsGameReallyOver = true;
	}

	// --- Utility Methods ---
	private int RollDie() {
		return rng.Next(1, 7);    // 6-sided die roll
	}

} // End of Game Class

#endregion Game Class


// ####################################################
// ########         PROGRAM ENTRY POINT        ########
// ####################################################

#region Program Entry Point

public class Program
{
	public static void Main(string[] args)
	{
		Console.WriteLine("=== Blade Runner: Rep-Detect Console ===");
		List<string> availableNames = new List<string> { "Deckard", "Gaff", "Bryant", "Holden" };
		string[] colors = { "Red", "Blue", "Green", "Yellow" };
		int totalPlayers = 0;
		while (totalPlayers < 2 || totalPlayers > 4) {
			Console.Write($"Total players (2-4): ");
			if (int.TryParse(Console.ReadLine(), out int input) && input >= 2 && input <= 4) totalPlayers = input;
			else Console.WriteLine("Invalid.");
		}
		int humanPlayers = -1;
		while (humanPlayers < 0 || humanPlayers > totalPlayers) {
			Console.Write($"Number of humans (0-{totalPlayers}): ");
			if (int.TryParse(Console.ReadLine(), out int input) && input >= 0 && input <= totalPlayers) humanPlayers = input;
			else Console.WriteLine("Invalid.");
		}
		int aiPlayers = totalPlayers - humanPlayers;
		List<Player> players = new List<Player>();
		Dictionary<string, IAgentController> controllers = new Dictionary<string, IAgentController>();

		// Create Human Players
		for (int i = 0; i < humanPlayers; i++) {
			Console.WriteLine($"\n--- Human Player {i + 1} Character Choice ---");
			Console.WriteLine("Available:");
			for(int j = 0; j < availableNames.Count; j++) Console.WriteLine($"{j + 1}: {availableNames[j]}");
			string chosenName = null;
			while (chosenName == null) {
				Console.Write($"Choose #: ");
				if (int.TryParse(Console.ReadLine(), out int choice) && choice > 0 && choice <= availableNames.Count) {
					chosenName = availableNames[choice - 1];
					availableNames.RemoveAt(choice - 1);
				}
				else Console.WriteLine("Invalid.");
			}
			string color = colors[i];
			players.Add(new Player(chosenName, color, $"{color} Home"));
			Console.WriteLine($"Human Player {i + 1} is {chosenName} ({color})");
		}
		// Create AI Players
		for (int i = 0; i < aiPlayers; i++) {
			int playerIndex = humanPlayers + i;
			string name = availableNames[0];
			availableNames.RemoveAt(0);
			string color = colors[playerIndex];
			Player aiPlayer = new Player(name, color, $"{color} Home");
			players.Add(aiPlayer);
			controllers.Add(name, new SimpleRuleBasedAgent());
			Console.WriteLine($"AI Player {i + 1} is {name} ({color})");
		}

		Console.WriteLine("\nStarting game...");
		Game repDetectGame = new Game(players, controllers);
		repDetectGame.StartGame();
		Console.WriteLine("\nEnd of Simulation. Press Enter to exit.");
		Console.ReadLine();
	}
}

#endregion Program Entry Point
